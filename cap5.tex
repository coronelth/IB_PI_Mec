\chapter{Conclusiones generales}
\graphicspath{{figs/cap4/}}
\label{cap5}

En el presente trabajo se realizó un código numérico para resolver problemas de transferencia de calor en flujos multifásicos con cambio de fase, en donde el método utilizado es el de lattice Boltzmann de dos ecuaciones pseudo-pontencial y operador MRT desarrollado por Fogliatto en \colorbox{green}{paper energia} . El modelo desarrollado resuelve problemas con discretización espacial de dominio regular y el tipo de modelo de grilla es el denominado D2Q9.

El código numérico fue desarrollado mediante el software \textsc{Git}, donde el repositorio utilizado es el de la página web \textsc{Git Hub} y puede ser descargado en \url{https://github.com/efogliatto/LBCUDA_Test}. \textsc{Git} permite controlar las versiones de los archivos que se encuentran en un repositorio de forma fácil y eficiente. En el transcurso del proyecto se comprobó que una buena práctica para desarrollar código es mediante el uso de ramas, donde para éste proyecto en particular se trabajó mediante tres niveles: \textit{master}, \textit{develop} y \textit{feature}. La versión 1.0 es la que se encontraba en la rama \textit{master} al finalizar el presente trabajo.

El código realizado utilizó como compilador el software \textsc{CMake}, el cual permite desarrollar proyectos que posean una gran cantidad de directorios de forma simple. El código se encuentra implementado en tres lenguajes de programación, siendo ellos \textsc{C}, \textsc{Cuda C} y \textsc{Python}. La compilación correspondiente a \textsc{C} se hizo en bibliotecas del tipo \textit{shared} mientras que las bibliotecas de \textsc{Cuda C} eran del tipo \textit{static}. Además los \textit{kernels} realizados en \textit{Cuda C} son compilados en formato \textsc{ptx} para que \textsc{Python} los utilice mediante su módulo llamado \textsc{PyCuda}.

Las instrucciones de compilación de \textit{CMake} se realizan por medio de un archivo de configuración principal llamado CMakeLists.txt. Se concretaron direferntes opciones de configuración para compilar el código, siendo ellas :

\begin{itemize}
	\item seleccionar el tipo de variable del código en simple precisión o doble precisión. 
	\item detección automática de la arquitectura de la GPU que cuenta la PC en donde se produce la compilación.
	\item posibilidad de compilar únicamente en \textsc{C} o en su defecto \textsc{C} y \textsc{Cuda C}.
\end{itemize}

La validación del código fue realizado en dos PC diferentes, la primera contaba con una CPU Intel Core i7-3770 con una GPU NVIDIA GeForce GTX 760 y la segunda disponia de una CPU Intel Core i7-4770 con una GPU NVIDIA GeForce GTX 970. A su vez la validación se concretó en variables de simple precisión y doble precisión.

Los problemas físicos  que se utilizaron para realizar la validación del código son los siguientes:

\begin{itemize}
    
    \item construcción de Maxwell, el cual obtiene las densidades de coexistencia de fases de un fluido 

    \item estratificación de un fluido Van der Waals con temperatura no uniforme; siéndo el problema unidimensional con campo gravitatorio y temperaturas fijas en los extremos.

    \item generación de burbujas en una placa horizontal calefaccionada.

\end{itemize}

\section{Construcción de Maxwell}

Para el problema de la Construcción de Maxwell, se reprodució el resultado que obtuvo Fogliatto en \cite{fogliatto2019simulation}, para el cual el valor del parámetro $\sigma = 0,125$ del operador MRT es el que ajusta mejor la curva de coexistencia de fases para un fluido con la Ecuación de estado de VdW de parámetros $ a = 0,5 $ y $ b = 4,0 $. 

Para la GPU NVIDIA Geforce GTX 760 en simple precisión se obtuvo una ganancia del código realizado en \textbf{CUDA C} de 18.67 veces con respecto al código de \textbf{C} para un número de 64 \textit{thread block} y la cantidad de 4194304 ($2^{22}$) elementos de malla. Mientras que en la  GPU NVIDIA Geforce GTX 970 en las mismas condiciones se obtuvo una ganancia de 23.39 utilizando 32 \textit{thread block} .

En doble precisión, la ganancia de la GPU NVIDIA Geforce GTX 760 con 64 \textit{thread block} fue de 11.40 mientras que en GPU NVIDIA Geforce GTX 970 con 32 \textit{thread block} se obtuvo 10.96 .

Por el comportamiento que se observó en los resultados, la GPU NVIDIA Geforce GTX 760 llegó a una ganancia máxima, mientras que la GPU NVIDIA Geforce GTX 970 posee la tendencia de aumentar su ganancia a un número de elementos de malla mayor.

Se comparó los resultados obtenidos en simple precisión y doble precisión en la validación de las curvas de coexistencia. Se obtuvo que la diferencia entre la distancia en simple precisión es de 0,003 \% mayor que doble precisión.

Debido a que no existe un gran beneficio en la mejora que se obtiene utilizando doble precisión, y puesto que el tiempo que se demora en doble precesión con respecto a simple precisión es de 1.68 y 1.29 según se utilice GPU NVIDIA Geforce GTX 760 y GPU NVIDIA Geforce GTX 970 respectivamente. Se recomienda la utilización en simple precisión del código realizado.

\section{Estratificación de un fluido VdW}

Para el problema unidimensional de la estratificación de un fluido VdW, se pudo verificar los perfiles de densidad $\rho_r$ y de temperatura $T_r$ a lo largo de la cavidad. 

La mayor ganancia que se obtuvo para la GPU NVIDIA Geforce GTX 760 y GPU NVIDIA Geforce GTX 970 en simple precisión fue de 13.26 y 15.95, siendo para doble precisión en 7.88 y 13.29, tomando como comparación el código de \textsc{Cuda C} con el código de \textsc{C}. En todos los casos con 64 \textit{thread block}.

Para una cantidad de 32 \textit{thread block} el código de \textsc{Cuda C}  en simple precisión es 1.77 y 1.25 veces más rápido que en doble precisión para  las GPU NVIDIA Geforce GTX 760 y GPU NVIDIA Geforce GTX 970 respectivamente. 

\section{Generación de burbujas en una superficie horizontal calefaccionada}

A partir del problema de la estratificación de un fluido VdW con temperatura no uniforme, el cual es unidimensional, se pudo realizar una pequeña modificación en el código, para agregar una condición de contorno de calefacción. En esencia el código es exactamente el mismo y puede reproducir el comportamiento de generación de una burbuja en el proceso de ebullición. 

Se demuestra de ésta manera que un fenómeno complejo puede ser resuelto mediante el LBM utilizado en el trabajo.

\section{Eficiencia en \textsc{Python}}

En el presente trabajo no se implementó, por falta de tiempo, un código que resuelva los problemas de transferencia de calor mencionados. Lo que sí se realizó, fue implementar mediante el módulo \textsc{PyCuda} de \textsc{Python} uno de los \textit{kernels} del código de \textsc{Cuda C}. Luego se comparo el tiempo de cálculo de \textit{Python} para el \textit{kernel} obtenido respecto al tiempo de cálculo del mismo en \textsc{Cuda C}. Se obtuvo en simple precisión que el incremento porcentual de el código en \textsc{Python} con respecto al código de \textit{Cuda C} es deñ 15 \% y 10 \% para las GPU NVIDIA Geforce GTX 760 y GPU NVIDIA Geforce GTX 970 respectivamente.

Al ser \textit{Python} un lenguaje interpretado que permite un avance rápido en escritura de código de programación y posee módulos que son eficientes para realizar algunas acciones específicas. Llegado el momento de tener que realizar un código se puede utilizar \textsc{Python} con sus módulos, y las funciones necesarias a eficientizar realizarlas en otros lenguaje, y utilizarla mediante alguno de los mismos módulos.


\section{Trabajo futuro}

Una de las líneas de desarrollo para éste trabajo es la mejora en los \textit{kernel} del código de \textsc{Cuda C} para que la ganancia en los tiempos de cálculo con respecto al del código de \textsc{C} aumente. Una de las formas de realizar ésto puede ser mediante la utilización de \textit{shared memory} ó \textit{local memory} de las \textit{thread block}. 

El código fue realizado para que la implementación en un modelo de grilla D3Q15 sea de forma sencilla, no se le tiene que realizar un gran cambio, sólo se tiene que agregar en el directorio \textit{latticeModel} éste tipo de modelo 

%Por otro lado se puede trabajar en el desarrollo de una forma distinta de almacenar la información de los nodos vecinos, debido a que cuando se accede al registro de la memoria para realizar el proceso de \textit{streaming}, no toda la información que toma al acceder sirve para el cálculo del \textit{streaming} de ése nodo. Por lo que 
%
%
% ya que cuando se realiza la lectura de los mismos no toda la memoria que es adquirida e utiliza toda la información y se debe investigar como almacenar la informació para queal momento de la lectura del registro correspondiente de memoria se maximice la utilización de ésa lectura.

%Una de las cosas que queda por investigar , es el almacenamiento de los valores de la función de distribución de poblaciones, debido a que en nuestro problema se poseen 3 matrices con la información. una de ellas es la matriz de vecinosy la siguiente es las de poblaciones. Puesto a que depende de cómo es la etiqueta que se realizan a los vecinos, éstos irán a ser buscados en la memoria de la maquina. Dependiendo de cómo estén almacenados los lugares de la memoria de los nodos vecinos, éstos pueden tardart más o menios. de ahí surge la posibilidad/idea de que se distribuya de una manera distinta la forma de almacenar la informacion de lkis nodos vecinos y así realizzar un al profiling que haga que el código tenga una mayor ganancia.

Por cuestión de tiempo no se llegó a implementar un código en \textsc{Python} utilizando la biblioteca \textsc{PyCuda}. Se mostró la implementacion para uno de los \textit{kernel}, pudiendo continuar el proyecto a partir de ahí. 

También se puede realizar una interfaz gráfica mediante \textsc{Python} para que el usuario pueda operar el código sin necesidad de saber utilizar la terminal. La compilación del código puede realizarse de cierta forma, tal que se utilice en el sistema operativo Windows, ya que actualmente se utiliza en Linux. 